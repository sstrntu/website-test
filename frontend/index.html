<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TURFMAPP</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">`
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Orbitron', monospace;
            cursor: crosshair;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

    </style>
</head>
<body>
    <div id="container"></div>
    

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        let scene, camera, renderer, controls, composer;
        let textMesh, fontLoader, outlineLineMaterial;
        let stadium, footballField, seating, floodlights, groundReflector;
        let atmosphericParticles = [];
        let isAnimationPlaying = true;
        let effectsEnabled = true;
        let performanceMode = 'high';
        let cameraTransitions = {};
        let isTransitioning = false;
        let raycaster, pointer;
        let clickableTargets = [];
        let activeOrbitTween = null;
        

        const container = document.getElementById('container');

        // Performance detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEnd = navigator.hardwareConcurrency <= 4 || isMobile;

        init();
        animate();

        function init() {
            // Scene setup for stadium atmosphere
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001122);
            scene.fog = new THREE.Fog(0x001122, 50, 500);

            // Camera setup - start from very far for dramatic intro
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(133.79450201043988, 47.854569820237366, 140.7443475920018); // Start from far zoom-out position

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: !isLowEnd,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            // Enhanced post-processing setup
            if (!isLowEnd) {
                composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                composer.addPass(renderPass);

                // Stadium-optimized bloom for dramatic floodlight effects
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    2.0,    // Higher bloom strength for stadium lights
                    0.3,    // Bloom radius
                    0.95    // Bloom threshold - only bright lights bloom
                );
                bloomPass.threshold = 0.95; // Only very bright elements bloom
                bloomPass.strength = 2.0;   // Dramatic stadium lighting
                bloomPass.radius = 0.3;     // Focused light halos
                composer.addPass(bloomPass);
                console.log('Enhanced bloom post-processing enabled');
            }

            // Enhanced controls with extended zoom range
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.minDistance = 1;      // Allow much closer inspection beyond default position
            controls.maxDistance = 200;    // Reasonable maximum distance from default position
            controls.maxPolarAngle = Math.PI * 0.48;
            controls.autoRotate = false;   // Disabled for intro sequence
            controls.autoRotateSpeed = 0.3;
            
            // Enhanced zoom sensitivity
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;

            // Lighting setup for stadium
            setupLighting();
            
            // Create football stadium
            createStadium();
            
            // Add reflective ground plane
            if (!isLowEnd) {
                createReflectiveGround();
            }
            
            // Add atmospheric particles
            if (!isLowEnd) {
                createAtmosphericParticles();
            }
            
            // Setup camera transitions
            setupCameraTransitions();
            
            // Setup UI interactions
            setupEventListeners();
            
            // Setup click-to-zoom interactions
            setupClickInteractions();
            
            // Performance optimization
            optimizeForDevice();
            
            // Start dramatic intro sequence
            setTimeout(() => {
                startIntroSequence();
            }, 200); // Shorter wait for scene to stabilize
            
        }

        function setupLighting() {
            console.log('Setting up cinematic stadium lighting...');
            
            // Reduced ambient for dramatic contrast
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
            scene.add(ambientLight);
            console.log('Low-key ambient light added');

            // Main stadium floodlights with dramatic intensity
            const floodlightPositions = [
                { x: -100, y: 150, z: -60, name: 'NW Tower' },
                { x: 100, y: 150, z: -60, name: 'NE Tower' },
                { x: -100, y: 150, z: 60, name: 'SW Tower' },
                { x: 100, y: 150, z: 60, name: 'SE Tower' }
            ];

            floodlights = [];
            floodlightPositions.forEach((pos, index) => {
                // Main powerful floodlight
                const floodlight = new THREE.SpotLight(
                    0xffffff,           // Pure white
                    8.0,                // High intensity for bloom effect
                    400,                // Long range
                    Math.PI * 0.25,     // Wide cone angle
                    0.3,                // Soft penumbra
                    1.5                 // Distance decay
                );
                
                floodlight.position.set(pos.x, pos.y, pos.z);
                floodlight.target.position.set(0, 0, 0);
                
                if (!isLowEnd) {
                    floodlight.castShadow = true;
                    floodlight.shadow.mapSize.width = 2048;
                    floodlight.shadow.mapSize.height = 2048;
                    floodlight.shadow.camera.near = 10;
                    floodlight.shadow.camera.far = 500;
                    floodlight.shadow.camera.fov = 45;
                }

                scene.add(floodlight);
                scene.add(floodlight.target);
                floodlights.push(floodlight);
                
                // Add light helper visualization (remove in production)
                if (!isLowEnd) {
                    const helper = new THREE.SpotLightHelper(floodlight);
                    helper.visible = false; // Hidden by default
                    scene.add(helper);
                }
            });

            // Rim lighting for dramatic silhouettes
            const rimLight = new THREE.DirectionalLight(0x8899ff, 2.0);
            rimLight.position.set(-200, 100, 200);
            scene.add(rimLight);

            // Atmospheric fill light
            const fillLight = new THREE.DirectionalLight(0xff8844, 0.8);
            fillLight.position.set(200, 50, -100);
            scene.add(fillLight);

            console.log(`Stadium lighting rig completed: ${floodlights.length} floodlights + atmospheric lighting`);
        }

        function createStadium() {
            // Try to load .blend file first, fallback to procedural generation
            loadStadiumModel();
        }

        function loadStadiumModel() {
            const loader = new GLTFLoader();
            
            // Setup Draco loader for compressed models
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.158.0/examples/jsm/libs/draco/');
            loader.setDRACOLoader(dracoLoader);

            // Load your stadium model
            loader.load(
                './assets/stadium.glb',
                function (gltf) {
                    console.log('Stadium model loaded successfully');
                    console.log('Model bounding box:', gltf.scene);
                    console.log('Model children:', gltf.scene.children);
                    
                    stadium = gltf.scene;
                    
                    // Get model dimensions for proper camera positioning
                    const box = new THREE.Box3().setFromObject(stadium);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    console.log('Model center:', center);
                    console.log('Model size:', size);
                    
                    // Position model at center
                    stadium.position.sub(center);
                    
                    // Scale if too small/large
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 0) {
                        const scale = maxDim < 10 ? 10 : maxDim > 200 ? 200/maxDim : 1;
                        stadium.scale.setScalar(scale);
                        console.log('Applied scale:', scale);
                    }
                    
                    // Enable shadows
                    stadium.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            console.log('Mesh found:', child.name, child.material);
                        }
                    });
                    
                    scene.add(stadium);
                    console.log('Stadium added to scene');
                    
                    // Keep camera at initial far position for intro sequence
                    // Camera will be moved by startIntroSequence() 
                    console.log('Stadium loaded - camera remains at starting position:', camera.position);
                    
                    // Create 3D text overlay for intro
                    create3DText();
                    
                    // If the model has animations, set them up
                    if (gltf.animations && gltf.animations.length) {
                        const mixer = new THREE.AnimationMixer(stadium);
                        gltf.animations.forEach((clip) => {
                            mixer.clipAction(clip).play();
                        });
                        console.log('Animations set up:', gltf.animations.length);
                    }
                },
                function (progress) {
                    console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                },
                function (error) {
                    console.error('Error loading stadium model:', error);
                    console.log('Falling back to procedural stadium generation');
                    createProceduralStadium();
                }
            );
        }

        function create3DText() {
            console.log('Creating 3D text overlay...');
            
            // Initialize font loader
            fontLoader = new FontLoader();
            
            // Load font and create text
            fontLoader.load(
                'https://unpkg.com/three@0.158.0/examples/fonts/helvetiker_regular.typeface.json',
                function (font) {
                    console.log('Font loaded successfully');
                    
                    // Use Three.js example approach - generateShapes for clean outlines
                    const message = 'TURFMAPP';
                    const shapes = font.generateShapes(message, 10); // Smaller text size
                    
                    // Create line material for outline
                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: 0x99c2ff,
                        transparent: true,
                        opacity: 1.0,
                        depthTest: false
                    });
                    
                    // Create fill material for a layered text effect (like the example)
                    const fillMaterial = new THREE.MeshBasicMaterial({
                        color: 0x99c2ff,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
                    
                    // Create geometry and center it
                    const shapeGeometry = new THREE.ShapeGeometry(shapes);
                    shapeGeometry.computeBoundingBox();
                    const centerOffsetX = -0.5 * (shapeGeometry.boundingBox.max.x - shapeGeometry.boundingBox.min.x);
                    const centerOffsetY = -0.5 * (shapeGeometry.boundingBox.max.y - shapeGeometry.boundingBox.min.y);
                    
                    // Handle holes in letters (like 'A', 'P', 'R')
                    const holeShapes = [];
                    for (let i = 0; i < shapes.length; i++) {
                        const shape = shapes[i];
                        if (shape.holes && shape.holes.length > 0) {
                            for (let j = 0; j < shape.holes.length; j++) {
                                const hole = shape.holes[j];
                                holeShapes.push(hole);
                            }
                        }
                    }
                    shapes.push(...holeShapes);
                    
                    // Create text object container
                    textMesh = new THREE.Object3D();
                    
                    // Add a semi-transparent filled mesh for the "3D" layered look
                    const filledGeometry = shapeGeometry.clone();
                    filledGeometry.translate(centerOffsetX, centerOffsetY, 0);
                    const filledMesh = new THREE.Mesh(filledGeometry, fillMaterial);
                    filledMesh.position.z = -25; // push fill further behind the outline for stronger depth
                    filledMesh.renderOrder = 1; // render first
                    textMesh.add(filledMesh);
                    
                    for (let i = 0; i < shapes.length; i++) {
                        const shape = shapes[i];
                        const points = shape.getPoints();
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        // Center geometry so the text is centered around its origin
                        geometry.translate(centerOffsetX, centerOffsetY, 0);
                        
                        const lineMesh = new THREE.Line(geometry, lineMaterial);
                        lineMesh.renderOrder = 2; // ensure outline draws on top
                        textMesh.add(lineMesh);
                    }
                    
                    // Position text centered in camera view
                    // Calculate position in front of camera at specified distance
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    
                    // Place text at a comfortable distance so the whole word is visible
                    const textDistance = 90; // Move closer to the camera
                    const textPosition = camera.position.clone();
                    textPosition.addScaledVector(cameraDirection, textDistance);
                    // Lift slightly in screen space so it's not cropped at the bottom
                    const cameraUpWorld = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
                    textPosition.addScaledVector(cameraUpWorld, 5);
                    
                    // Position the text object at the calculated position
                    textMesh.position.copy(textPosition);
                    
                    // Geometry already centered; no world-space offset needed
                    
                    // Make text face the camera for proper viewing
                    textMesh.lookAt(camera.position);
                    
                    scene.add(textMesh);
                    console.log('3D text added to scene at position:', textMesh.position);
                },
                function (progress) {
                    console.log('Font loading progress:', progress);
                },
                function (error) {
                    console.error('Error loading font:', error);
                    console.log('3D text creation failed - continuing without text');
                }
            );
        }

        function createProceduralStadium() {
            // Create football field
            createFootballField();
            
            // Create stadium seating
            createSeating();
            
            // Create floodlight towers
            if (!isLowEnd) {
                createFloodlightTowers();
            }
        }

        function createFootballField() {
            // Main field geometry
            const fieldGeometry = new THREE.PlaneGeometry(105, 68);
            const fieldMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d5a2d
            });
            footballField = new THREE.Mesh(fieldGeometry, fieldMaterial);
            footballField.rotation.x = -Math.PI / 2;
            footballField.position.y = 0;
            footballField.receiveShadow = true;
            scene.add(footballField);
            clickableTargets.push(footballField);

            // Field markings
            const lineGeometry = new THREE.PlaneGeometry(105, 2);
            const lineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });

            // Center line
            const centerLine = new THREE.Mesh(lineGeometry, lineMaterial);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.set(0, 0.01, 0);
            scene.add(centerLine);

            // Goal area lines
            const goalAreaGeometry = new THREE.PlaneGeometry(40, 2);
            const goalArea1 = new THREE.Mesh(goalAreaGeometry, lineMaterial);
            goalArea1.rotation.x = -Math.PI / 2;
            goalArea1.position.set(0, 0.01, -16.5);
            scene.add(goalArea1);

            const goalArea2 = new THREE.Mesh(goalAreaGeometry, lineMaterial);
            goalArea2.rotation.x = -Math.PI / 2;
            goalArea2.position.set(0, 0.01, 16.5);
            scene.add(goalArea2);

            // Center circle
            const circleGeometry = new THREE.RingGeometry(9.15, 9.65, 32);
            const circleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const centerCircle = new THREE.Mesh(circleGeometry, circleMaterial);
            centerCircle.rotation.x = -Math.PI / 2;
            centerCircle.position.set(0, 0.01, 0);
            scene.add(centerCircle);

            // Goals
            const goalPostGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2.44);
            const goalPostMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });

            // Goal 1
            const goalPost1 = new THREE.Mesh(goalPostGeometry, goalPostMaterial);
            goalPost1.position.set(-3.66, 1.22, -34);
            scene.add(goalPost1);

            const goalPost2 = new THREE.Mesh(goalPostGeometry, goalPostMaterial);
            goalPost2.position.set(3.66, 1.22, -34);
            scene.add(goalPost2);

            const crossbar1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 7.32), goalPostMaterial);
            crossbar1.rotation.z = Math.PI / 2;
            crossbar1.position.set(0, 2.44, -34);
            scene.add(crossbar1);

            // Goal 2
            const goalPost3 = new THREE.Mesh(goalPostGeometry, goalPostMaterial);
            goalPost3.position.set(-3.66, 1.22, 34);
            scene.add(goalPost3);

            const goalPost4 = new THREE.Mesh(goalPostGeometry, goalPostMaterial);
            goalPost4.position.set(3.66, 1.22, 34);
            scene.add(goalPost4);

            const crossbar2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 7.32), goalPostMaterial);
            crossbar2.rotation.z = Math.PI / 2;
            crossbar2.position.set(0, 2.44, 34);
            scene.add(crossbar2);
        }

        function createSeating() {
            const seatingGroup = new THREE.Group();
            
            // Stadium bowl structure
            const stadiumGeometry = new THREE.RingGeometry(60, 120, 32, 1, 0, Math.PI * 2);
            const stadiumMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x666666,
                side: THREE.DoubleSide
            });
            
            // Create tiered seating
            for (let tier = 0; tier < 4; tier++) {
                const tierGeometry = new THREE.RingGeometry(65 + tier * 12, 75 + tier * 12, 32);
                const tierMaterial = new THREE.MeshLambertMaterial({ 
                    color: tier % 2 === 0 ? 0x4a4a4a : 0x555555
                });
                const tierMesh = new THREE.Mesh(tierGeometry, tierMaterial);
                tierMesh.rotation.x = -Math.PI / 2;
                tierMesh.position.y = 5 + tier * 8;
                tierMesh.receiveShadow = true;
                seatingGroup.add(tierMesh);
            }
            
            // Stadium outer wall
            const wallGeometry = new THREE.CylinderGeometry(125, 120, 50, 32, 1, true);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.y = 25;
            wall.receiveShadow = true;
            seatingGroup.add(wall);
            
            scene.add(seatingGroup);
            seating = seatingGroup;
            clickableTargets.push(seatingGroup);
        }

        function createFloodlightTowers() {
            // Create floodlight tower structures
            const towerGeometry = new THREE.CylinderGeometry(1, 2, 100);
            const towerMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            
            const positions = [
                [-90, 50, -50],
                [90, 50, -50],
                [-90, 50, 50],
                [90, 50, 50]
            ];
            
            positions.forEach((pos, index) => {
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.set(pos[0], pos[1], pos[2]);
                tower.castShadow = true;
                scene.add(tower);
                
                // Floodlight housing
                const housingGeometry = new THREE.BoxGeometry(4, 2, 2);
                const housingMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                const housing = new THREE.Mesh(housingGeometry, housingMaterial);
                housing.position.set(pos[0], pos[1] + 50, pos[2]);
                scene.add(housing);
            });
        }

        function createReflectiveGround() {
            console.log('Creating reflective ground plane...');
            
            // Create large reflective ground plane beneath stadium
            const groundGeometry = new THREE.PlaneGeometry(400, 400);
            
            // Use Reflector for realistic reflections (Jesse's technique)
            groundReflector = new Reflector(groundGeometry, {
                clipBias: 0.003,
                textureWidth: isLowEnd ? 512 : 1024,  // Lower res for performance
                textureHeight: isLowEnd ? 512 : 1024,
                color: 0x333344,  // Subtle blue tint
                recursion: 1
            });
            
            groundReflector.position.y = -5; // Below stadium
            groundReflector.rotateX(-Math.PI / 2);
            scene.add(groundReflector);
            
            // Add subtle fog/mist above reflective surface
            const mistGeometry = new THREE.PlaneGeometry(400, 400);
            const mistMaterial = new THREE.MeshBasicMaterial({
                color: 0x222244,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const mist = new THREE.Mesh(mistGeometry, mistMaterial);
            mist.position.y = -4.5;
            mist.rotateX(-Math.PI / 2);
            scene.add(mist);
            
            console.log('Reflective ground plane created with wet asphalt effect');
        }

        function setupCameraTransitions() {
            // Predefined cinematic camera positions (Jesse's technique)
            cameraTransitions = {
                aerial: {
                    position: { x: 0, y: 200, z: 200 },
                    target: { x: 0, y: 0, z: 0 },
                    name: 'Aerial Overview'
                },
                fieldLevel: {
                    position: { x: 0, y: 5, z: 50 },
                    target: { x: 0, y: 0, z: 0 },
                    name: 'Field Level'
                },
                cornerKick: {
                    position: { x: 45, y: 15, z: 30 },
                    target: { x: 52, y: 0, z: 34 },
                    name: 'Corner Kick View'
                },
                goalLine: {
                    position: { x: 0, y: 8, z: 40 },
                    target: { x: 0, y: 2, z: -40 },
                    name: 'Goal Line Perspective'
                },
                sideline: {
                    position: { x: 80, y: 25, z: 0 },
                    target: { x: 0, y: 0, z: 0 },
                    name: 'Sideline View'
                },
                default: {
                    position: { x: 0, y: 100, z: 150 },
                    target: { x: 0, y: 0, z: 0 },
                    name: 'Default View'
                }
            };
            
            console.log('Camera transition system initialized with', Object.keys(cameraTransitions).length, 'viewpoints');
        }

        function transitionToView(viewName, duration = 2.0) {
            if (isTransitioning || !cameraTransitions[viewName]) {
                console.log('Transition blocked or invalid view:', viewName);
                return;
            }
            
            const view = cameraTransitions[viewName];
            isTransitioning = true;
            
            console.log('Transitioning to:', view.name);
            
            // Disable controls during transition (Jesse's method)
            controls.enableRotate = false;
            controls.enableZoom = false;
            controls.enablePan = false;
            
            // Smooth camera position transition
            gsap.to(camera.position, {
                x: view.position.x,
                y: view.position.y,
                z: view.position.z,
                duration: duration,
                ease: "power2.inOut"
            });
            
            // Smooth target transition
            gsap.to(controls.target, {
                x: view.target.x,
                y: view.target.y,
                z: view.target.z,
                duration: duration,
                ease: "power2.inOut",
                onComplete: () => {
                    // Re-enable controls after transition
                    controls.enableRotate = true;
                    controls.enableZoom = true;
                    controls.enablePan = true;
                    isTransitioning = false;
                    console.log('Transition to', view.name, 'completed');
                }
            });
        }

        function startAutoTour() {
            const viewNames = Object.keys(cameraTransitions).filter(name => name !== 'default');
            let currentViewIndex = 0;
            
            const tourInterval = setInterval(() => {
                if (currentViewIndex >= viewNames.length) {
                    clearInterval(tourInterval);
                    transitionToView('default', 3.0); // Return to default
                    console.log('Auto-tour completed');
                    return;
                }
                
                transitionToView(viewNames[currentViewIndex], 2.5);
                currentViewIndex++;
            }, 6000); // 6 seconds per view
            
            console.log('Auto-tour started');
        }

        function startIntroSequence() {
            console.log('Starting zoom sequence: text -> stadium flythrough...');
            
            // Disable user controls during intro
            controls.enableRotate = false;
            controls.enableZoom = false;
            controls.enablePan = false;
            
            // Phase 1: Brief hold on text
            setTimeout(() => {
                // Phase 2: Fade out text while zooming past it
                if (textMesh) {
                    gsap.to(textMesh.material, {
                        opacity: 0,
                        duration: 0.6,
                        ease: "power2.out",
                        onComplete: () => {
                            scene.remove(textMesh);
                            console.log('3D text faded out and removed');
                        }
                    });
                    
                    // Also scale text slightly for extra effect
                    gsap.to(textMesh.scale, {
                        x: 1.2,
                        y: 1.2,
                        z: 1.2,
                        duration: 0.6,
                        ease: "power2.out"
                    });
                }
                
                // Phase 3: Fast dramatic zoom from far position to default position
                gsap.to(camera.position, {
                    x: 19.4319229067779,
                    y: 9.883097359294862,
                    z: 21.532109433098107,
                    duration: 1.8,  // Faster zoom
                    ease: "power3.out",  // More dramatic easing
                    onComplete: () => {
                        // Re-enable user controls after intro
                        controls.enableRotate = true;
                        controls.enableZoom = true;
                        controls.enablePan = true;
                        console.log('Zoom sequence complete - user controls enabled');
                        console.log('Default position reached - scroll to zoom closer for inspection');
                    }
                });
                
                // Update controls target to focus on stadium center
                gsap.to(controls.target, {
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 1.8,
                    ease: "power3.out"
                });
                
            }, 250); // Short hold before starting zoom
        }

        function createAtmosphericParticles() {
            console.log('Creating atmospheric particle systems...');
            
            // Dust motes in light beams (Jesse's technique)
            const dustCount = isLowEnd ? 80 : 200; // fewer dust squares
            const dustGeometry = new THREE.BufferGeometry();
            const dustPositions = new Float32Array(dustCount * 3);
            const dustVelocities = new Float32Array(dustCount * 3);
            
            for (let i = 0; i < dustCount; i++) {
                dustPositions[i * 3] = (Math.random() - 0.5) * 300;      // x
                dustPositions[i * 3 + 1] = Math.random() * 100 + 20;      // y
                dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 300;   // z
                
                dustVelocities[i * 3] = (Math.random() - 0.5) * 0.02;      // vx
                dustVelocities[i * 3 + 1] = -Math.random() * 0.01 - 0.005; // vy (falling)
                dustVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;  // vz
            }
            
            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute('velocity', new THREE.BufferAttribute(dustVelocities, 3));
            
            const dustMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2.0,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            const dustParticles = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dustParticles);
            atmosphericParticles.push({
                particles: dustParticles,
                type: 'dust',
                geometry: dustGeometry
            });
            
            // Stadium atmosphere/mist disabled (blue squares removed)
            
            console.log('Atmospheric particles created:', atmosphericParticles.length, 'systems');
        }

        function animateParticles() {
            if (!atmosphericParticles.length) return;
            
            atmosphericParticles.forEach(system => {
                const positions = system.geometry.attributes.position.array;
                
                if (system.type === 'dust') {
                    const velocities = system.geometry.attributes.velocity.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // Apply velocity
                        positions[i] += velocities[i];
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2];
                        
                        // Reset particles that fall too low
                        if (positions[i + 1] < -10) {
                            positions[i] = (Math.random() - 0.5) * 300;
                            positions[i + 1] = 100 + Math.random() * 50;
                            positions[i + 2] = (Math.random() - 0.5) * 300;
                        }
                        
                        // Wrap particles that drift too far
                        if (Math.abs(positions[i]) > 150) positions[i] = -positions[i];
                        if (Math.abs(positions[i + 2]) > 150) positions[i + 2] = -positions[i + 2];
                    }
                } else if (system.type === 'mist') {
                    // Gentle floating motion for mist
                    const time = Date.now() * 0.0002;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += Math.sin(time + i) * 0.02;
                        positions[i + 1] += Math.cos(time + i * 0.1) * 0.01;
                        positions[i + 2] += Math.cos(time + i) * 0.02;
                    }
                }
                
                system.geometry.attributes.position.needsUpdate = true;
            });
        }

        function optimizeForDevice() {
            if (isLowEnd) {
                performanceMode = 'low';
                renderer.shadowMap.enabled = false;
                controls.autoRotate = false;
                effectsEnabled = false;
            }
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            
            // Keyboard controls for camera transitions (testing/demo)
            window.addEventListener('keydown', (event) => {
                switch(event.key) {
                    case '1':
                        transitionToView('aerial');
                        break;
                    case '2':
                        transitionToView('fieldLevel');
                        break;
                    case '3':
                        transitionToView('cornerKick');
                        break;
                    case '4':
                        transitionToView('goalLine');
                        break;
                    case '5':
                        transitionToView('sideline');
                        break;
                    case '0':
                        transitionToView('default');
                        break;
                    case 't':
                    case 'T':
                        startAutoTour();
                        break;
                }
            });
            
            console.log('Event listeners setup - Press 1-5 for camera views, T for auto-tour');
        }

        function setupClickInteractions() {
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('click', onPointerClick);
        }
        
        function onPointerMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(pointer, camera);
            const targetHits = raycaster.intersectObjects(clickableTargets, true);
            document.body.style.cursor = targetHits.length ? 'pointer' : 'crosshair';
        }
        
        function onPointerClick(event) {
            if (isTransitioning) return;
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(pointer, camera);
            // Click-to-zoom anywhere on field/stadium
            const targetHits = raycaster.intersectObjects(clickableTargets, true);
            if (targetHits.length) {
                const hit = targetHits[0];
                flyToPointWithOrbit(hit.point);
            }
        }

        function flyToPointWithOrbit(point) {
            // Compute a camera position offset from the clicked point
            const toCamera = camera.position.clone().sub(controls.target).normalize();
            const offsetDistance = 12; // how close to get
            const targetPosition = point.clone().addScaledVector(toCamera, offsetDistance).add(new THREE.Vector3(0, 4, 0));
            
            isTransitioning = true;
            controls.enableRotate = false;
            controls.enableZoom = false;
            controls.enablePan = false;
            
            gsap.to(camera.position, {
                x: targetPosition.x,
                y: targetPosition.y,
                z: targetPosition.z,
                duration: 1.2,
                ease: "power2.inOut"
            });
            
            gsap.to(controls.target, {
                x: point.x,
                y: point.y,
                z: point.z,
                duration: 1.2,
                ease: "power2.inOut",
                onComplete: () => {
                    // Orbit around the point for a moment
                    const start = { angle: 0 };
                    const radius = 10;
                    const up = new THREE.Vector3(0, 1, 0);
                    const right = new THREE.Vector3().subVectors(camera.position, point).cross(up).normalize();
                    const aroundUp = up.clone();
                    
                    activeOrbitTween = gsap.to(start, {
                        angle: Math.PI * 2 * 0.25, // quarter turn
                        duration: 2.0,
                        ease: "sine.inOut",
                        onUpdate: () => {
                            const dir = new THREE.Vector3().copy(aroundUp).multiplyScalar(Math.cos(start.angle)).add(right.clone().multiplyScalar(Math.sin(start.angle)));
                            camera.position.copy(point).addScaledVector(dir.normalize(), radius).add(new THREE.Vector3(0, 4, 0));
                            camera.lookAt(point);
                        },
                        onComplete: () => {
                            controls.enableRotate = true;
                            controls.enableZoom = true;
                            controls.enablePan = true;
                            isTransitioning = false;
                        }
                    });
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Debug: Log render info occasionally
            if (Math.random() < 0.001) {
                console.log('Rendering... Camera pos:', camera.position);
                console.log('Scene children:', scene.children.length);
            }

            // Animations
            if (isAnimationPlaying) {
                // Dynamic floodlight intensity for dramatic effect
                if (floodlights) {
                    const time = Date.now() * 0.001;
                    floodlights.forEach((light, index) => {
                        // Enhanced stadium lighting with more dramatic variation
                        light.intensity = 8.0 + Math.sin(time * 0.5 + index) * 1.5 + Math.random() * 0.2;
                    });
                }
                
                // Animate atmospheric particles
                animateParticles();
            }

            controls.update();

            // Render with enhanced post-processing pipeline
            if (composer && effectsEnabled) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Disable intro animation for debugging
        // gsap.fromTo(camera.position, 
        //     { x: 200, y: 200, z: 200 },
        //     { x: 0, y: 100, z: 150, duration: 4, ease: "power2.out", delay: 1 }
        // );
        
        console.log('Script loaded, animation loop started');
    </script>
</body>
</html>