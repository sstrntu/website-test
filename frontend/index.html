<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TURFMAPP</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">`
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Orbitron', monospace;
            cursor: crosshair;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }


    </style>
</head>
<body>
    <div id="container"></div>
    
    

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        let scene, camera, renderer, controls, composer;
        let textMesh, fontLoader, outlineLineMaterial;
        let stadium, footballField, seating, floodlights, groundReflector, groundMist;
        let atmosphericParticles = [];
        let isAnimationPlaying = true;
        let effectsEnabled = true;
        let performanceMode = 'high';
        let cameraTransitions = {};
        let isTransitioning = false;
        let raycaster, pointer;
        let clickableTargets = [];
        let activeOrbitTween = null;
        
        // Multi-scale system variables  
        let sphere, sphereRadius = 1500; // Much bigger sphere to be clearly visible at distance
        let currentZoomScale = 'sphere'; // 'sphere', 'stadium', 'detail'
        let scaleThresholds = {
            sphere: { min: 2500, max: Infinity },
            stadium: { min: 200, max: 2500 },  // Adjusted for better text visibility
            detail: { min: 1, max: 200 }       // Text only shows when very close
        };
        let sphereVisible = true;
        let stadiumTextVisible = false;
        let stadiumDetailVisible = false;
        let hasSeenIntroSequence = false;
        let worldSpaceText; // 2D text positioned next to the stadium
        

        const container = document.getElementById('container');
        

        // Performance detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEnd = navigator.hardwareConcurrency <= 4 || isMobile;

        init();
        animate();

        function init() {
            // Scene setup for stadium atmosphere
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x001122);
            scene.fog = new THREE.Fog(0x001122, 50, 8000); // Extended fog range for sphere visibility

            // Camera setup - start far enough back to see the complete sphere
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 15000);
            camera.position.set(0, 0, 4000); // Start far enough to see complete sphere

            // Renderer setup - optimized for performance
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, // Disable antialiasing to reduce load
                powerPreference: "default" // Use default instead of high-performance
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Lower pixel ratio
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false; // Disable shadows to reduce load
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);


            // Enhanced controls with extended zoom range for sphere-to-detail
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.minDistance = 1;      // Allow much closer inspection beyond default position
            controls.maxDistance = 6000;   // Extended for complete sphere view
            controls.maxPolarAngle = Math.PI * 0.48;
            controls.autoRotate = false;   // Disabled for intro sequence
            controls.autoRotateSpeed = 0.3;
            
            // Enhanced zoom sensitivity
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;

            // Create sphere first
            createSphere();
            
            // Lighting setup for stadium
            setupLighting();
            
            // Create football stadium
            createStadium();
            
            // Add reflective ground plane (will be hidden at sphere scale)
            if (!isLowEnd) {
                createReflectiveGround();
            }
            
            
            // Setup camera transitions
            setupCameraTransitions();
            
            // Setup UI interactions
            setupEventListeners();
            
            // Setup click-to-zoom interactions
            setupClickInteractions();
            
            // Performance optimization
            optimizeForDevice();
            
            // Start zoom sequence immediately
            startIntroSequence();
            
        }

        function createSphere() {
            console.log('Creating clean wireframe sphere...');
            
            // Create sphere container
            sphere = new THREE.Group();
            
            // Create horizontal circles (latitude lines)
            const latitudes = 16;
            for (let i = 1; i < latitudes; i++) {
                const phi = (i / latitudes) * Math.PI;
                const y = sphereRadius * Math.cos(phi);
                const radius = sphereRadius * Math.sin(phi);
                
                const circleGeometry = new THREE.RingGeometry(radius, radius, 32);
                const circleMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1.0
                });
                
                // Convert ring to line
                const points = [];
                for (let j = 0; j <= 32; j++) {
                    const theta = (j / 32) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        radius * Math.cos(theta),
                        y,
                        radius * Math.sin(theta)
                    ));
                }
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeometry, circleMaterial);
                sphere.add(line);
            }
            
            // Create vertical circles (longitude lines)
            const longitudes = 16;
            for (let i = 0; i < longitudes; i++) {
                const theta = (i / longitudes) * Math.PI * 2;
                
                const points = [];
                for (let j = 0; j <= 32; j++) {
                    const phi = (j / 32) * Math.PI;
                    points.push(new THREE.Vector3(
                        sphereRadius * Math.sin(phi) * Math.cos(theta),
                        sphereRadius * Math.cos(phi),
                        sphereRadius * Math.sin(phi) * Math.sin(theta)
                    ));
                }
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1.0
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                sphere.add(line);
            }
            
            // Position sphere at origin
            sphere.position.set(0, 0, 0);
            
            scene.add(sphere);
            clickableTargets.push(sphere);
            
            // Make sure camera is looking at the sphere
            controls.target.set(0, 0, 0);
            
            console.log('Clean wireframe sphere created with radius:', sphereRadius);
        }

        function setupLighting() {
            console.log('Setting up cinematic stadium lighting...');
            
            // Reduced ambient for dramatic contrast
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
            scene.add(ambientLight);
            console.log('Low-key ambient light added');

            // Main stadium floodlights with dramatic intensity
            const floodlightPositions = [
                { x: -100, y: 150, z: -60, name: 'NW Tower' },
                { x: 100, y: 150, z: -60, name: 'NE Tower' },
                { x: -100, y: 150, z: 60, name: 'SW Tower' },
                { x: 100, y: 150, z: 60, name: 'SE Tower' }
            ];

            floodlights = [];
            floodlightPositions.forEach((pos, index) => {
                // Main powerful floodlight
                const floodlight = new THREE.SpotLight(
                    0xffffff,           // Pure white
                    8.0,                // High intensity for bloom effect
                    400,                // Long range
                    Math.PI * 0.25,     // Wide cone angle
                    0.3,                // Soft penumbra
                    1.5                 // Distance decay
                );
                
                floodlight.position.set(pos.x, pos.y, pos.z);
                floodlight.target.position.set(0, 0, 0);
                
                // Start with reduced intensity (will increase at detail scale)
                floodlight.intensity = 2.0;
                

                scene.add(floodlight);
                scene.add(floodlight.target);
                floodlights.push(floodlight);
                
                // Add light helper visualization (remove in production)
                if (!isLowEnd) {
                    const helper = new THREE.SpotLightHelper(floodlight);
                    helper.visible = false; // Hidden by default
                    scene.add(helper);
                }
            });

            // Rim lighting for dramatic silhouettes
            const rimLight = new THREE.DirectionalLight(0x8899ff, 2.0);
            rimLight.position.set(-200, 100, 200);
            scene.add(rimLight);

            // Atmospheric fill light
            const fillLight = new THREE.DirectionalLight(0xff8844, 0.8);
            fillLight.position.set(200, 50, -100);
            scene.add(fillLight);

            console.log(`Stadium lighting rig completed: ${floodlights.length} floodlights + atmospheric lighting`);
        }

        function createStadium() {
            // Try to load .blend file first, fallback to procedural generation
            loadStadiumModel();
        }

        function loadStadiumModel() {
            const loader = new GLTFLoader();
            
            // Setup Draco loader for compressed models
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.158.0/examples/jsm/libs/draco/');
            loader.setDRACOLoader(dracoLoader);

            // Load your stadium model
            loader.load(
                './assets/stadium.glb',
                function (gltf) {
                    console.log('Stadium model loaded successfully');
                    console.log('Model bounding box:', gltf.scene);
                    console.log('Model children:', gltf.scene.children);
                    
                    stadium = gltf.scene;
                    
                    // Get model dimensions for proper camera positioning
                    const box = new THREE.Box3().setFromObject(stadium);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    console.log('Model center:', center);
                    console.log('Model size:', size);
                    
                    // Position model at center
                    stadium.position.sub(center);
                    
                    // Scale if too small/large
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 0) {
                        const scale = maxDim < 10 ? 10 : maxDim > 200 ? 200/maxDim : 1;
                        stadium.scale.setScalar(scale);
                        console.log('Applied scale:', scale);
                    }
                    
                    // Start with stadium completely invisible (will appear when zooming in)
                    stadium.visible = false;
                    
                    // Hide all stadium children materials initially
                    stadium.traverse((child) => {
                        if (child.isMesh) {
                            child.visible = false;
                            console.log('Mesh found and hidden:', child.name, child.material);
                            
                            // Also hide materials
                            if (child.material) {
                                // Handle both single materials and arrays
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.transparent = true;
                                        mat.opacity = 0.0;
                                    });
                                } else {
                                    child.material.transparent = true;
                                    child.material.opacity = 0.0;
                                }
                            }
                        }
                    });
                    
                    scene.add(stadium);
                    console.log('Stadium added to scene');
                    
                    // Keep camera at initial far position for intro sequence
                    // Camera will be moved by startIntroSequence() 
                    console.log('Stadium loaded - camera remains at starting position:', camera.position);
                    
                    // Create 3D text overlay for intro
                    create3DText();
                    
                    // Create Jesse Zhou style world-space text
                    createWorldSpaceText();
                    
                    // If the model has animations, set them up
                    if (gltf.animations && gltf.animations.length) {
                        const mixer = new THREE.AnimationMixer(stadium);
                        gltf.animations.forEach((clip) => {
                            mixer.clipAction(clip).play();
                        });
                        console.log('Animations set up:', gltf.animations.length);
                    }
                },
                function (progress) {
                    console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                },
                function (error) {
                    console.error('Error loading stadium model:', error);
                    console.log('No fallback stadium - keeping clean sphere view');
                    // createProceduralStadium(); // Disabled to keep sphere clean
                }
            );
        }

        function create3DText() {
            console.log('Creating 3D text overlay...');
            
            // Check if TextGeometry is available
            if (typeof TextGeometry === 'undefined') {
                console.error('TextGeometry not available');
                return;
            }
            
            // Initialize font loader
            fontLoader = new FontLoader();
            
            // Load font and create text (using bold font for better Jesse Zhou style)
            fontLoader.load(
                'https://unpkg.com/three@0.158.0/examples/fonts/helvetiker_bold.typeface.json',
                function (font) {
                    console.log('Font loaded successfully');
                    
                    // Create Jesse Zhou style 3D text with depth and bevel
                    const message = 'TURFMAPP';
                    
                    // Create 3D text geometry with Jesse Zhou inspired settings
                    const textGeometry = new TextGeometry(message, {
                        font: font,
                        size: 12, // Larger size for better visibility
                        height: 3,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.8,
                        bevelSize: 0.5,
                        bevelOffset: 0,
                        bevelSegments: 8
                    });
                    
                    // Center the text
                    textGeometry.computeBoundingBox();
                    const centerOffsetX = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                    const centerOffsetY = -0.5 * (textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y);
                    textGeometry.translate(centerOffsetX, centerOffsetY, 0);
                    
                    // Create Jesse Zhou style materials
                    const mainMaterial = new THREE.MeshPhongMaterial({
                        color: 0x00ff00, // Neon green
                        emissive: new THREE.Color(0x00ff00).multiplyScalar(0.5), // Stronger glow for visibility
                        shininess: 100,
                        transparent: true,
                        opacity: 1.0
                    });
                    
                    // Outline material for depth
                    const outlineMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(0x00ff00).multiplyScalar(0.3),
                        transparent: true,
                        opacity: 0.8,
                        side: THREE.BackSide
                    });
                    
                    // Store original opacities
                    mainMaterial.userData.originalOpacity = 1.0;
                    outlineMaterial.userData.originalOpacity = 0.8;
                    
                    // Create text object container
                    textMesh = new THREE.Group();
                    
                    // Main 3D text mesh
                    const mainTextMesh = new THREE.Mesh(textGeometry, mainMaterial);
                    textMesh.add(mainTextMesh);
                    
                    // Create outline for depth (Jesse Zhou style)
                    const outlineGeometry = textGeometry.clone();
                    const outlineMesh = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineMesh.scale.setScalar(1.05);
                    outlineMesh.position.z = -0.1;
                    textMesh.add(outlineMesh);
                    
                    // Position text prominently above the stadium
                    textMesh.position.set(0, 50, 0); // Higher above the stadium for better visibility
                    
                    // Geometry already centered; no world-space offset needed
                    
                    // Start with text completely invisible (will appear when zooming in)
                    textMesh.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = 0.0;
                            child.material.transparent = true; // Ensure transparency is enabled
                        }
                    });
                    textMesh.visible = false; // Completely hide initially
                    
                    scene.add(textMesh);
                    console.log('3D text added to scene at position:', textMesh.position);
                },
                function (progress) {
                    console.log('Font loading progress:', progress);
                },
                function (error) {
                    console.error('Error loading font:', error);
                    console.log('3D text creation failed - continuing without text');
                }
            );
        }

        function createWorldSpaceText() {
            console.log('Creating Jesse Zhou style 2D text overlay...');
            
            // Create HTML text element positioned in 3D space
            const textDiv = document.createElement('div');
            textDiv.innerHTML = `
                <div style="font-family: 'Orbitron', monospace; color: white; font-size: 14px; text-align: left;">
                    <div style="font-weight: bold; font-size: 16px; margin-bottom: 2px;">Turfmapp</div>
                    <div style="font-size: 12px; opacity: 0.8;">ACSS</div>
                </div>
            `;
            textDiv.style.position = 'fixed';
            textDiv.style.pointerEvents = 'none';
            textDiv.style.zIndex = '100';
            textDiv.style.opacity = '0';
            textDiv.style.transition = 'opacity 0.8s ease';
            
            document.body.appendChild(textDiv);
            worldSpaceText = textDiv; // Store reference
            
            console.log('Jesse Zhou style 2D text created');
        }

        // Function to position 2D text next to the 3D stadium
        function updateWorldSpaceTextPosition() {
            if (!worldSpaceText || !camera || !renderer) return;
            
            // 3D position to the right of stadium
            const stadiumPosition = new THREE.Vector3(10, 5, 5);
            
            // Project 3D position to screen coordinates
            const screenPosition = stadiumPosition.clone().project(camera);
            
            // Convert to screen pixels
            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
            
            // Update HTML text position
            worldSpaceText.style.left = `${x}px`;
            worldSpaceText.style.top = `${y}px`;
        }

        function createProceduralStadium() {
            // Create football field
            createFootballField();
            
            // Create stadium seating
            createSeating();
            
            // Create floodlight towers
            if (!isLowEnd) {
                createFloodlightTowers();
            }
        }

        function createFootballField() {
            // Main field geometry
            const fieldGeometry = new THREE.PlaneGeometry(105, 68);
            const fieldMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d5a2d
            });
            footballField = new THREE.Mesh(fieldGeometry, fieldMaterial);
            footballField.rotation.x = -Math.PI / 2;
            footballField.position.y = 0;
            footballField.receiveShadow = true;
            scene.add(footballField);
            clickableTargets.push(footballField);

            // Field markings
            const lineGeometry = new THREE.PlaneGeometry(105, 2);
            const lineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });

            // Center line
            const centerLine = new THREE.Mesh(lineGeometry, lineMaterial);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.set(0, 0.01, 0);
            scene.add(centerLine);

            // Goal area lines
            const goalAreaGeometry = new THREE.PlaneGeometry(40, 2);
            const goalArea1 = new THREE.Mesh(goalAreaGeometry, lineMaterial);
            goalArea1.rotation.x = -Math.PI / 2;
            goalArea1.position.set(0, 0.01, -16.5);
            scene.add(goalArea1);

            const goalArea2 = new THREE.Mesh(goalAreaGeometry, lineMaterial);
            goalArea2.rotation.x = -Math.PI / 2;
            goalArea2.position.set(0, 0.01, 16.5);
            scene.add(goalArea2);

            // Center circle
            const circleGeometry = new THREE.RingGeometry(9.15, 9.65, 32);
            const circleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const centerCircle = new THREE.Mesh(circleGeometry, circleMaterial);
            centerCircle.rotation.x = -Math.PI / 2;
            centerCircle.position.set(0, 0.01, 0);
            scene.add(centerCircle);

            // Goals
            const goalPostGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2.44);
            const goalPostMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });

            // Goal 1
            const goalPost1 = new THREE.Mesh(goalPostGeometry, goalPostMaterial);
            goalPost1.position.set(-3.66, 1.22, -34);
            scene.add(goalPost1);

            const goalPost2 = new THREE.Mesh(goalPostGeometry, goalPostMaterial);
            goalPost2.position.set(3.66, 1.22, -34);
            scene.add(goalPost2);

            const crossbar1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 7.32), goalPostMaterial);
            crossbar1.rotation.z = Math.PI / 2;
            crossbar1.position.set(0, 2.44, -34);
            scene.add(crossbar1);

            // Goal 2
            const goalPost3 = new THREE.Mesh(goalPostGeometry, goalPostMaterial);
            goalPost3.position.set(-3.66, 1.22, 34);
            scene.add(goalPost3);

            const goalPost4 = new THREE.Mesh(goalPostGeometry, goalPostMaterial);
            goalPost4.position.set(3.66, 1.22, 34);
            scene.add(goalPost4);

            const crossbar2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 7.32), goalPostMaterial);
            crossbar2.rotation.z = Math.PI / 2;
            crossbar2.position.set(0, 2.44, 34);
            scene.add(crossbar2);
        }

        function createSeating() {
            const seatingGroup = new THREE.Group();
            
            // Stadium bowl structure
            const stadiumGeometry = new THREE.RingGeometry(60, 120, 32, 1, 0, Math.PI * 2);
            const stadiumMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x666666,
                side: THREE.DoubleSide
            });
            
            // Create tiered seating
            for (let tier = 0; tier < 4; tier++) {
                const tierGeometry = new THREE.RingGeometry(65 + tier * 12, 75 + tier * 12, 32);
                const tierMaterial = new THREE.MeshLambertMaterial({ 
                    color: tier % 2 === 0 ? 0x4a4a4a : 0x555555
                });
                const tierMesh = new THREE.Mesh(tierGeometry, tierMaterial);
                tierMesh.rotation.x = -Math.PI / 2;
                tierMesh.position.y = 5 + tier * 8;
                tierMesh.receiveShadow = true;
                seatingGroup.add(tierMesh);
            }
            
            // Stadium outer wall
            const wallGeometry = new THREE.CylinderGeometry(125, 120, 50, 32, 1, true);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.y = 25;
            wall.receiveShadow = true;
            seatingGroup.add(wall);
            
            scene.add(seatingGroup);
            seating = seatingGroup;
            clickableTargets.push(seatingGroup);
        }

        function createFloodlightTowers() {
            // Create floodlight tower structures
            const towerGeometry = new THREE.CylinderGeometry(1, 2, 100);
            const towerMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            
            const positions = [
                [-90, 50, -50],
                [90, 50, -50],
                [-90, 50, 50],
                [90, 50, 50]
            ];
            
            positions.forEach((pos, index) => {
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.set(pos[0], pos[1], pos[2]);
                tower.castShadow = true;
                scene.add(tower);
                
                // Floodlight housing
                const housingGeometry = new THREE.BoxGeometry(4, 2, 2);
                const housingMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                const housing = new THREE.Mesh(housingGeometry, housingMaterial);
                housing.position.set(pos[0], pos[1] + 50, pos[2]);
                scene.add(housing);
            });
        }

        function createReflectiveGround() {
            console.log('Creating reflective ground plane...');
            
            // Create large reflective ground plane beneath stadium
            const groundGeometry = new THREE.PlaneGeometry(400, 400);
            
            // Use Reflector for realistic reflections (Jesse's technique)
            groundReflector = new Reflector(groundGeometry, {
                clipBias: 0.003,
                textureWidth: isLowEnd ? 512 : 1024,  // Lower res for performance
                textureHeight: isLowEnd ? 512 : 1024,
                color: 0x333344,  // Subtle blue tint
                recursion: 1
            });
            
            groundReflector.position.y = -5; // Below stadium
            groundReflector.rotateX(-Math.PI / 2);
            
            // Start with reflective ground hidden (will appear when zooming in)
            groundReflector.visible = false;
            
            scene.add(groundReflector);
            
            // Add subtle fog/mist above reflective surface
            const mistGeometry = new THREE.PlaneGeometry(400, 400);
            const mistMaterial = new THREE.MeshBasicMaterial({
                color: 0x222244,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            groundMist = new THREE.Mesh(mistGeometry, mistMaterial);
            groundMist.position.y = -4.5;
            groundMist.rotateX(-Math.PI / 2);
            
            // Start with mist hidden (will appear when zooming in)
            groundMist.visible = false;
            
            scene.add(groundMist);
            
            console.log('Reflective ground plane created with wet asphalt effect');
        }

        function setupCameraTransitions() {
            // Predefined cinematic camera positions (Jesse's technique)
            cameraTransitions = {
                aerial: {
                    position: { x: 0, y: 200, z: 200 },
                    target: { x: 0, y: 0, z: 0 },
                    name: 'Aerial Overview'
                },
                fieldLevel: {
                    position: { x: 0, y: 5, z: 50 },
                    target: { x: 0, y: 0, z: 0 },
                    name: 'Field Level'
                },
                cornerKick: {
                    position: { x: 45, y: 15, z: 30 },
                    target: { x: 52, y: 0, z: 34 },
                    name: 'Corner Kick View'
                },
                goalLine: {
                    position: { x: 0, y: 8, z: 40 },
                    target: { x: 0, y: 2, z: -40 },
                    name: 'Goal Line Perspective'
                },
                sideline: {
                    position: { x: 80, y: 25, z: 0 },
                    target: { x: 0, y: 0, z: 0 },
                    name: 'Sideline View'
                },
                default: {
                    position: { x: 0, y: 100, z: 150 },
                    target: { x: 0, y: 0, z: 0 },
                    name: 'Default View'
                }
            };
            
            console.log('Camera transition system initialized with', Object.keys(cameraTransitions).length, 'viewpoints');
        }

        function transitionToView(viewName, duration = 2.0) {
            if (isTransitioning || !cameraTransitions[viewName]) {
                console.log('Transition blocked or invalid view:', viewName);
                return;
            }
            
            const view = cameraTransitions[viewName];
            isTransitioning = true;
            
            console.log('Transitioning to:', view.name);
            
            // Disable controls during transition (Jesse's method)
            controls.enableRotate = false;
            controls.enableZoom = false;
            controls.enablePan = false;
            
            // Smooth camera position transition
            gsap.to(camera.position, {
                x: view.position.x,
                y: view.position.y,
                z: view.position.z,
                duration: duration,
                ease: "power2.inOut"
            });
            
            // Smooth target transition
            gsap.to(controls.target, {
                x: view.target.x,
                y: view.target.y,
                z: view.target.z,
                duration: duration,
                ease: "power2.inOut",
                onComplete: () => {
                    // Re-enable controls after transition
                    controls.enableRotate = true;
                    controls.enableZoom = true;
                    controls.enablePan = true;
                    isTransitioning = false;
                    console.log('Transition to', view.name, 'completed');
                }
            });
        }

        function startAutoTour() {
            const viewNames = Object.keys(cameraTransitions).filter(name => name !== 'default');
            let currentViewIndex = 0;
            
            const tourInterval = setInterval(() => {
                if (currentViewIndex >= viewNames.length) {
                    clearInterval(tourInterval);
                    transitionToView('default', 3.0); // Return to default
                    console.log('Auto-tour completed');
                    return;
                }
                
                transitionToView(viewNames[currentViewIndex], 2.5);
                currentViewIndex++;
            }, 6000); // 6 seconds per view
            
            console.log('Auto-tour started');
        }

        function startIntroSequence() {
            console.log('Starting sphere-to-stadium zoom sequence...');
            
            // Disable user controls during intro
            controls.enableRotate = false;
            controls.enableZoom = false;
            controls.enablePan = false;
            
            console.log('Starting instant zoom to stadium...');
            
            // Immediate continuous zoom from sphere directly to detail view
            gsap.to(camera.position, {
                x: 19.4319229067779,
                y: 9.883097359294862,
                z: 21.532109433098107,
                duration: 2.0, // Faster zoom duration (reduced from 5.0)
                ease: "power1.inOut", // Smooth continuous zoom
                onComplete: () => {
                    // Re-enable user controls after intro
                    controls.enableRotate = true;
                    controls.enableZoom = true;
                    controls.enablePan = true;
                    hasSeenIntroSequence = true; // Mark intro as completed
                    
                    // Permanently remove TURFMAPP text after intro
                    if (textMesh) {
                        scene.remove(textMesh);
                        textMesh = null;
                        console.log('TURFMAPP text permanently removed after intro');
                    }
                    
                    console.log('Zoom sequence complete - user controls enabled');
                }
            });
        }

        function createAtmosphericParticles() {
            console.log('Creating atmospheric particle systems...');
            
            // Dust motes in light beams (Jesse's technique)
            const dustCount = isLowEnd ? 80 : 200; // fewer dust squares
            const dustGeometry = new THREE.BufferGeometry();
            const dustPositions = new Float32Array(dustCount * 3);
            const dustVelocities = new Float32Array(dustCount * 3);
            
            for (let i = 0; i < dustCount; i++) {
                dustPositions[i * 3] = (Math.random() - 0.5) * 300;      // x
                dustPositions[i * 3 + 1] = Math.random() * 100 + 20;      // y
                dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 300;   // z
                
                dustVelocities[i * 3] = (Math.random() - 0.5) * 0.02;      // vx
                dustVelocities[i * 3 + 1] = -Math.random() * 0.01 - 0.005; // vy (falling)
                dustVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;  // vz
            }
            
            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute('velocity', new THREE.BufferAttribute(dustVelocities, 3));
            
            const dustMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2.0,
                transparent: true,
                opacity: 0.05, // Start with low opacity (will increase at detail scale)
                blending: THREE.AdditiveBlending
            });
            
            const dustParticles = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dustParticles);
            atmosphericParticles.push({
                particles: dustParticles,
                type: 'dust',
                geometry: dustGeometry
            });
            
            // Stadium atmosphere/mist disabled (blue squares removed)
            
            console.log('Atmospheric particles created:', atmosphericParticles.length, 'systems');
        }

        function animateParticles() {
            if (!atmosphericParticles.length) return;
            
            atmosphericParticles.forEach(system => {
                const positions = system.geometry.attributes.position.array;
                
                if (system.type === 'dust') {
                    const velocities = system.geometry.attributes.velocity.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // Apply velocity
                        positions[i] += velocities[i];
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2];
                        
                        // Reset particles that fall too low
                        if (positions[i + 1] < -10) {
                            positions[i] = (Math.random() - 0.5) * 300;
                            positions[i + 1] = 100 + Math.random() * 50;
                            positions[i + 2] = (Math.random() - 0.5) * 300;
                        }
                        
                        // Wrap particles that drift too far
                        if (Math.abs(positions[i]) > 150) positions[i] = -positions[i];
                        if (Math.abs(positions[i + 2]) > 150) positions[i + 2] = -positions[i + 2];
                    }
                } else if (system.type === 'mist') {
                    // Gentle floating motion for mist
                    const time = Date.now() * 0.0002;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += Math.sin(time + i) * 0.02;
                        positions[i + 1] += Math.cos(time + i * 0.1) * 0.01;
                        positions[i + 2] += Math.cos(time + i) * 0.02;
                    }
                }
                
                system.geometry.attributes.position.needsUpdate = true;
            });
        }

        function optimizeForDevice() {
            if (isLowEnd) {
                performanceMode = 'low';
                renderer.shadowMap.enabled = false;
                controls.autoRotate = false;
                effectsEnabled = false;
            }
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            
            // Keyboard controls for camera transitions (testing/demo)
            window.addEventListener('keydown', (event) => {
                switch(event.key) {
                    case '1':
                        transitionToView('aerial');
                        break;
                    case '2':
                        transitionToView('fieldLevel');
                        break;
                    case '3':
                        transitionToView('cornerKick');
                        break;
                    case '4':
                        transitionToView('goalLine');
                        break;
                    case '5':
                        transitionToView('sideline');
                        break;
                    case '0':
                        transitionToView('default');
                        break;
                    case 't':
                    case 'T':
                        startAutoTour();
                        break;
                    case 'g':
                    case 'G':
                        // Jump to sphere scale
                        gsap.to(camera.position, {
                            x: 0, y: 0, z: 4000,
                            duration: 1.5,
                            ease: "power2.inOut"
                        });
                        break;
                    case 's':
                    case 'S':
                        // Jump to stadium scale
                        gsap.to(camera.position, {
                            x: 0, y: 0, z: 1200,
                            duration: 1.5,
                            ease: "power2.inOut"
                        });
                        break;
                    case 'd':
                    case 'D':
                        // Jump to detail scale
                        gsap.to(camera.position, {
                            x: 19.43, y: 9.88, z: 21.53,
                            duration: 1.5,
                            ease: "power2.inOut"
                        });
                        break;
                }
            });
            
            console.log('Event listeners setup:');
            console.log('- Press 1-5 for camera views, T for auto-tour');
            console.log('- Press G for sphere view, S for stadium view, D for detail view');
            console.log('- Use scroll wheel to zoom smoothly between all scales');
        }

        function setupClickInteractions() {
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('click', onPointerClick);
        }
        
        function onPointerMove(event) {
            // Keep default cursor since clicking is disabled
            document.body.style.cursor = 'default';
        }
        
        function onPointerClick(event) {
            // DISABLED click-to-zoom to prevent weird jumping behavior
            // User should only use scroll wheel and keyboard controls
            return;
        }

        function flyToPointWithOrbit(point) {
            // Compute a camera position offset from the clicked point
            const toCamera = camera.position.clone().sub(controls.target).normalize();
            const offsetDistance = 12; // how close to get
            const targetPosition = point.clone().addScaledVector(toCamera, offsetDistance).add(new THREE.Vector3(0, 4, 0));
            
            isTransitioning = true;
            controls.enableRotate = false;
            controls.enableZoom = false;
            controls.enablePan = false;
            
            gsap.to(camera.position, {
                x: targetPosition.x,
                y: targetPosition.y,
                z: targetPosition.z,
                duration: 1.2,
                ease: "power2.inOut"
            });
            
            gsap.to(controls.target, {
                x: point.x,
                y: point.y,
                z: point.z,
                duration: 1.2,
                ease: "power2.inOut",
                onComplete: () => {
                    // Orbit around the point for a moment
                    const start = { angle: 0 };
                    const radius = 10;
                    const up = new THREE.Vector3(0, 1, 0);
                    const right = new THREE.Vector3().subVectors(camera.position, point).cross(up).normalize();
                    const aroundUp = up.clone();
                    
                    activeOrbitTween = gsap.to(start, {
                        angle: Math.PI * 2 * 0.25, // quarter turn
                        duration: 2.0,
                        ease: "sine.inOut",
                        onUpdate: () => {
                            const dir = new THREE.Vector3().copy(aroundUp).multiplyScalar(Math.cos(start.angle)).add(right.clone().multiplyScalar(Math.sin(start.angle)));
                            camera.position.copy(point).addScaledVector(dir.normalize(), radius).add(new THREE.Vector3(0, 4, 0));
                            camera.lookAt(point);
                        },
                        onComplete: () => {
                            controls.enableRotate = true;
                            controls.enableZoom = true;
                            controls.enablePan = true;
                            isTransitioning = false;
                        }
                    });
                }
            });
        }

        function updateScaleBasedVisibility() {
            // Calculate distance from camera to center (0,0,0)
            const distance = camera.position.distanceTo(controls.target);
            
            let newScale = currentZoomScale;
            if (distance >= scaleThresholds.sphere.min) {
                newScale = 'sphere';
            } else if (distance >= scaleThresholds.stadium.min) {
                newScale = 'stadium';
            } else {
                newScale = 'detail';
            }
            
            // If scale changed, update visibility
            if (newScale !== currentZoomScale) {
                // Removed debug console.log for cleaner experience
                currentZoomScale = newScale;
                
                // Update element visibility based on current scale
                updateElementVisibility();
            }
        }
        
        function updateElementVisibility() {
            // Sphere visibility - since it's now a Group, handle differently
            const shouldShowSphere = currentZoomScale === 'sphere';
            if (shouldShowSphere !== sphereVisible) {
                sphereVisible = shouldShowSphere;
                if (sphere) {
                    // Sphere is now a Group, so animate visibility on children materials
                    const targetOpacity = shouldShowSphere ? 1.0 : 0.0;
                    
                    sphere.children.forEach(line => {
                        if (line.material) {
                            gsap.to(line.material, {
                                opacity: targetOpacity,
                                duration: 0.8,
                                ease: "power2.inOut"
                            });
                        }
                    });
                    gsap.to(sphere.scale, {
                        x: shouldShowSphere ? 1.0 : 0.8,
                        y: shouldShowSphere ? 1.0 : 0.8,
                        z: shouldShowSphere ? 1.0 : 0.8,
                        duration: 0.8,
                        ease: "power2.inOut"
                    });
                }
            }
            
            // Stadium text visibility - only show during first zoom sequence, then permanently hidden
            const shouldShowStadiumText = !hasSeenIntroSequence && currentZoomScale !== 'sphere';
            if (shouldShowStadiumText !== stadiumTextVisible) {
                stadiumTextVisible = shouldShowStadiumText;
                if (textMesh) {
                    textMesh.visible = shouldShowStadiumText;
                    if (shouldShowStadiumText) {
                        // Fade in text (only during first sequence)
                        textMesh.children.forEach(child => {
                            if (child.material) {
                                gsap.to(child.material, {
                                    opacity: child.material.userData.originalOpacity || 1.0,
                                    duration: 0.8,
                                    ease: "power2.inOut"
                                });
                            }
                        });
                    }
                }
            }
            
            // Stadium visibility - show when not at sphere scale
            const shouldShowStadium = currentZoomScale !== 'sphere';
            if (stadium && stadium.visible !== shouldShowStadium) {
                stadium.visible = shouldShowStadium;
                
                // Also show/hide all stadium children
                stadium.traverse((child) => {
                    if (child.isMesh) {
                        child.visible = shouldShowStadium;
                        if (child.material) {
                            // Handle both single materials and arrays
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            
                            materials.forEach(mat => {
                                if (shouldShowStadium) {
                                    // Fade in stadium
                                    gsap.to(mat, {
                                        opacity: 1.0,
                                        duration: 0.8,
                                        ease: "power2.inOut"
                                    });
                                } else {
                                    // Fade out stadium
                                    mat.opacity = 0.0;
                                }
                            });
                        }
                    }
                });
            }
            
            // Reflective ground visibility - show when not at sphere scale
            const shouldShowGround = currentZoomScale !== 'sphere';
            if (groundReflector && groundReflector.visible !== shouldShowGround) {
                groundReflector.visible = shouldShowGround;
            }
            if (groundMist && groundMist.visible !== shouldShowGround) {
                groundMist.visible = shouldShowGround;
            }
            
            // Stadium detail visibility
            const shouldShowDetail = currentZoomScale === 'detail';
            if (shouldShowDetail !== stadiumDetailVisible) {
                stadiumDetailVisible = shouldShowDetail;
                
                
                // Show/hide world-space text (Jesse Zhou style) - visible at stadium and detail scale
                if (worldSpaceText) {
                    const shouldShowWorldText = currentZoomScale === 'stadium' || currentZoomScale === 'detail';
                    worldSpaceText.style.opacity = shouldShowWorldText ? '1' : '0';
                }
                
                // Floodlights visibility
                if (floodlights) {
                    floodlights.forEach(light => {
                        gsap.to(light, {
                            intensity: shouldShowDetail ? 8.0 : 2.0,
                            duration: 0.8,
                            ease: "power2.inOut"
                        });
                    });
                }
                
                // Atmospheric particles
                if (atmosphericParticles.length) {
                    atmosphericParticles.forEach(system => {
                        gsap.to(system.particles.material, {
                            opacity: shouldShowDetail ? 0.3 : 0.05,
                            duration: 0.8,
                            ease: "power2.inOut"
                        });
                    });
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update scale-based visibility
            updateScaleBasedVisibility();
            
            // Update 2D text position next to stadium
            updateWorldSpaceTextPosition();

            // Debug logging disabled for cleaner console experience

            // Animations
            if (isAnimationPlaying) {
                const time = Date.now() * 0.001;
                
                // Sphere is now static - no automatic rotation
                
                // Dynamic floodlight intensity for dramatic effect (only in detail mode)
                if (floodlights && currentZoomScale === 'detail') {
                    floodlights.forEach((light, index) => {
                        // Enhanced stadium lighting with more dramatic variation
                        const baseIntensity = stadiumDetailVisible ? 8.0 : 2.0;
                        light.intensity = baseIntensity + Math.sin(time * 0.5 + index) * 1.5 + Math.random() * 0.2;
                    });
                }
                
                
                // Make text always face camera when visible
                if (textMesh && currentZoomScale === 'stadium') {
                    textMesh.lookAt(camera.position);
                }
            }

            controls.update();

            // Render with basic rendering (post-processing disabled for performance)
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Disable intro animation for debugging
        // gsap.fromTo(camera.position, 
        //     { x: 200, y: 200, z: 200 },
        //     { x: 0, y: 100, z: 150, duration: 4, ease: "power2.out", delay: 1 }
        // );
        
        console.log('Script loaded, animation loop started');
    </script>
</body>
</html>